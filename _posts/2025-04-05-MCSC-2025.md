---
title: "Writeup MCSC 2025 Prequalification"
date: 2025-04-05
categories: [CTF,CRYPTO, Writeup]
tags: [SIGNATURE, CTF, ELGAMAL, DIFFIE-HELLMAN, ECC]
---

Tout rÃ©cemment, jâ€™ai eu lâ€™occasion de participer Ã  la phase prÃ©liminaire du CTF MCSC en ligne.  
Je vais tenter dâ€™expliquer les approches que jâ€™ai adoptÃ©es pour rÃ©soudre les challenges de cryptographie (oui, jâ€™adore les problÃ¨mes complexes â€“ plus câ€™est difficile, plus Ã§a mâ€™excite !).

---

# SIGN

## Source

```python
from Crypto.Util.number import getPrime, long_to_bytes, bytes_to_long
from random import randint
from Crypto.Util.number import GCD
from secret import sda3
with open("flag.txt", 'r') as f:
    flag = f.read()
Messages = []
p = getPrime(1024)
g = 3
k = randint(2, p - 2)
x = randint(1, p - 2)
y = pow(g, x, p)
o=0

while o==0:
    if GCD(k, p - 1) != 1:
        k = randint(2, p - 2)
        continue
    else:
        o=1       
def gen_keys():
    return (x, y, p, g)
def sign(answer: int, x: int):
    while True:
        m = answer
        r = pow(g, k, p) 
        s = (m - x * r) * pow(k, -1, p - 1) % (p - 1)
        assert(GCD(r, p - 1)==1)
        if s == 0:
            continue
        return (r, s)
def verify(answer, r, s):
    m = answer
    if any([x <= 0 or x >= p - 1 for x in [m, r, s]]):
        return False
    return pow(g, m, p) == (pow(y, r, p) * pow(r, s, p)) % p
def intercept():
    m = randint(0, getPrime(1000) - 1)
    r, s = sign(m, x)
    _, y, p, g = gen_keys()
    return r, s, m, y, p, g 
small=[]
def main():
    i = 0
    while i < 3:
        if i==2:
            if sda3(small,p) :
                print("all good")
            else:
                print("Wa ykon khir ykon khir. Something is seeking coprimalitytyty")
                return 0
        x, y, p, g = gen_keys()
        inp = int(input('khtar: '))
        r, s, m, y, p, g = intercept()
        small.append(s)
        Messages.append(m)

        if inp == 1:
            print(f"[{r}, {s}, {m}, {y}, {p}, {g}]")
        elif inp == 2:
            inp2 = input('Prove that nta howa nta: ').split(',')
            m1, r1, s1, y = [int(i) for i in inp2]
            if m1 in Messages:
                return 0
            elif verify(m1, r1, s1):
                print(flag)
            else:
                return 0
        else:
            return 0
        i+=1
if __name__ == "__main__":
    main()

```

Jâ€™avoue, jâ€™ai eu un petit moment de panique en voyant le code source, parce quâ€™en gÃ©nÃ©ral, les challenges que je rÃ©sous nâ€™ont pas un code aussi dense.  
Et comme je suis un peu flemmard, jâ€™ai soumis le code Ã  ChatGPT (bon, moi je lâ€™appelle Socrate). Il mâ€™a sorti lâ€™idÃ©e gÃ©nÃ©rale : je voyais **ELGAMAL**, **SIGNATURE**, **VULNÃ‰RABILITÃ‰ MÃŠME k**.  
Ã€ partir de lÃ , jâ€™Ã©tais un peu perdu, car câ€™Ã©tait la premiÃ¨re fois que je voyais ElGamal dans un CTF, mÃªme si je connaissais globalement lâ€™algorithme.

Jâ€™explique briÃ¨vement comment fonctionne la signature avec ElGamal â€“ câ€™est important pour comprendre ce qui va suivre.
### ParamÃ¨tres

```
- un grand nombre premier p
- un nombre g, appelÃ© gÃ©nÃ©rateur
- un nombre alÃ©atoire x âˆˆ [1, pâˆ’2], câ€™est la clÃ© privÃ©e
- une clÃ© publique : (g, p, g^x mod p)
- un nombre k âˆˆ [2, pâˆ’2] tel que gcd(k, pâˆ’1) = 1
```

### Signature

La signature dâ€™un message `m` est un couple de nombres `(r, s)` :

```
r = g^k mod p
s = (m âˆ’ x * r) * kâ»Â¹ mod (p âˆ’ 1)
```

### VÃ©rification

VÃ©rifier quâ€™une signature est correcte revient Ã  vÃ©rifier que :

```
g^m â‰¡ y^r * r^s mod p
```

Je ne sais pas vraiment pourquoi ces formules fonctionnent, mais contentons-nous de cela pour le moment.  
Ã‡a y est, on a tout ce quâ€™il nous faut pour comprendre le code.

---

## Analyse

Globalement, le programme demande un message et sa signature Ã  lâ€™utilisateur, et vÃ©rifie si la signature est correcte.  
Si câ€™est le cas, il affiche le flag.

Notre objectif est de forger un message `m` et une signature valide.

On a deux options :

```python
inp = int(input('khtar: '))
r, s, m, y, p, g = intercept()
small.append(s)
Messages.append(m)

if inp == 1:
    print(f"[{r}, {s}, {m}, {y}, {p}, {g}]")
```

Intercepter un message et sa signature pour lâ€™afficher.

Ou bien :

```python
elif inp == 2:
    inp2 = input('Prove that nta howa nta: ').split(',')
    m1, r1, s1, y = [int(i) for i in inp2]
    if m1 in Messages:
        return 0
    elif verify(m1, r1, s1):
        print(flag)
    else:
        return 0
```

Fournir un message et sa signature.

Dâ€™abord, dÃ©cortiquons la fonction **intercept** :

```python
def intercept():
    m = randint(0, getPrime(1000) - 1)
    r, s = sign(m, x)
    _, y, p, g = gen_keys()
    return r, s, m, y, p, g
```

Elle gÃ©nÃ¨re juste un message alÃ©atoire `m` et le signe.

Mais comment le signe-t-elle ?

```python
def sign(answer: int, x: int):
    while True:
        m = answer
        r = pow(g, k, p)
        s = (m - x * r) * pow(k, -1, p - 1) % (p - 1)
        assert(GCD(r, p - 1) == 1)
        if s == 0:
            continue
        return (r, s)
```

Elle le signe comme dÃ©crit dans la thÃ©orie, rien de compliquÃ©.

Cependant, **oÃ¹ se trouve la vulnÃ©rabilitÃ© ?**

La fonction principale nous permet dâ€™intercepter **au plus trois messages signÃ©s**, **et tous avec les mÃªmes paramÃ¨tres** `x`, `k`.  
Câ€™est lÃ  que rÃ©side le danger, car si jâ€™intercepte deux messages diffÃ©rents, je peux retrouver `k`, et ensuite `x`.

Voyons cela :

```
r = g^k mod p                (1)
s1 = (m1 - x * r) * kâ»Â¹ mod (p âˆ’ 1)   (2)
s2 = (m2 - x * r) * kâ»Â¹ mod (p âˆ’ 1)   (3)

donc :
s1 âˆ’ s2 = (m1 âˆ’ m2) * kâ»Â¹ mod (p âˆ’ 1)
â†’ k = (m1 âˆ’ m2) * (s1 âˆ’ s2)â»Â¹ mod (p âˆ’ 1)

Et Ã  partir de lÃ , on peut retrouver :
x = râ»Â¹ * (m1 âˆ’ s1 * k) mod (p âˆ’ 1)
```

---

## Solution

Intercepter deux signatures, ensuite dÃ©duire `k` puis `x`.  
Puis forger un troisiÃ¨me message et calculer sa signature.

Voici mon code final :

```python
from Crypto.Util.number import inverse

# Valeurs donnÃ©es pour deux signatures
r1 = ...
s1 = ...
m1 = ...

r2 = ...
s2 = ...
m2 = ...

# Calcul de k
delta_m = m1 - m2
delta_s = s1 - s2
k = (delta_m * inverse(delta_s, p - 1)) % (p - 1)

# Calcul de x
x = (inverse(r1, p - 1) * (m1 - s1 * k)) % (p - 1)

# Nouveau message
m3 = 1234567890
r3 = pow(g, k, p)
s3 = ((m3 - x * r3) * inverse(k, p - 1)) % (p - 1)
# Envoi de [m3, r3, s3, y] pour obtenir le flag
```

Et voilÃ  !  
Ce challenge mâ€™a appris plein de choses, surtout sur les signatures ElGamal et sur lâ€™importance de **ne jamais rÃ©utiliser la mÃªme valeur `k` pour signer deux messages diffÃ©rents.**

## NIST

Ce challenge a eu **0 solve**.

Je n'ai pas rÃ©ussi Ã  le rÃ©soudre le jour de la compet, mais jâ€™aurais puâ€¦  
Si jâ€™avais Ã©tÃ© concentrÃ©. C'Ã©tait juste une simple rÃ©duction de lattice en trois dimensions.

### ðŸ”Ž Source

```python
from Crypto.Util.number import getPrime, bytes_to_long, isPrime
import random

flag = bytes_to_long(b"MCSC{fake_flag}")
p = getPrime(512) 
g = 2

def SlowDown(number, total_bits, look):
    lookhere = total_bits - look
    role = (number >> lookhere) & ((1 << look) - 1)
    return role << lookhere  

try:
    E = random.randint(100, 270)
    a = random.randint(1, p - 1)
    b = random.randint(1, p - 1)
    c = random.randint(1, p - 1)

    A = pow(g, a, p) 
    B = pow(g, b, p) 
    s = pow(B, a, p) 
    D = pow(g, (a + c) * b, p)

    rrrrrr = SlowDown(s, 512, E)
    bakha = SlowDown(D, 512, E)

    print("g =", hex(g))
    print("B =", hex(B))
    print("p =", p)
    print("rrrrrr =", hex(rrrrrr))
    print("bakha =", hex(bakha))
    print("c =", hex(c))

    t = getPrime(512)
    while not isPrime(s):
        s += 1
    n = t * s

    print("ExNotChangeable =", pow(flag, 65537, n))
    print("n =", n)
    exit()

except:
    pass
```
Rien de compliquÃ© dans le code, une simple idÃ©e gÃ©nÃ©rale proposÃ©e par ChatGPT vous Ã©claircira lâ€™esprit.

### â„¹ï¸ Informations :
- RSA : on connaÃ®t `n`, `cipher`, `e`
- `n = t * s`

Tout le problÃ¨me rÃ©side dans la maniÃ¨re dont `s` est gÃ©nÃ©rÃ© :

```python
rrrrrr = SlowDown(s, 512, E)
bakha = SlowDown(D, 512, E)
```

La fonction **SlowDown** extrait juste les **(512 - E)** bits de poids fort de `S` et `D`.

Si on regarde plus haut :

```python
D = pow(g, (a + c) * b, p)
```

Ce qui Ã©quivaut Ã  :

```python
D = S * B^c mod p
```

Soit :

- `D = bakha + x`  
- `S = rrrrrr + y`  
- `Z = B^c mod p`

On a donc :
```
bakha + x = (rrrrrr + y) * Z mod p
```
Ce qui Ã©quivaut Ã  :
```
y * Z + (Z * rrrrrr - bakha) % p + k * p = x       (1)
```
DonnÃ©es :

- `Z` : 512 bits  
- `(Z * rrrrrr - bakha) % p` : 512 bits  
- `p` : 512 bits  
- `x`, `y` : `E` bits chacun (entre 100 et 270)

Ce qui nous suggÃ¨re que `x` et `y` sont assez petits.  
On peut alors construire un **lattice** Ã  partir de lâ€™Ã©quation (1).

### ðŸ§± Construction du lattice :

```text
[p,                      0, 0]
[Z,                      1, 0]
[(Z * rrrrrr - bakha)%p, 0, B]
```

Avec `B = 2^242`.  
(Normalement `B = 1`, mais une telle rÃ©duction ne permettrait pas de trouver `x` et `y` Ã  cause de la condition de Minkowski qui ne serait pas respectÃ©e.)

Je couvrirais les lattices dans une sÃ©rie de tutos oÃ¹ jâ€™expliquerai tout Ã§a en dÃ©tail.

La machine est prÃªte pour lâ€™attaque ðŸ”¥

### âœ… Solution

```python
from gmpy2 import next_prime
from Crypto.Util.number import *
from sage.all import *

g = 0x2
e = 0x10001
B = 0xba4f9d6f3e706e08021a110495da9d352c6eff1bfcaf185e5de7218a983254dd9a388a6ec3103c99e480348020fc20d8ff62f71bd1a5eb52ff12d7abc3c6b1c3
p = 11093148136126840032240100493378787250505687428694568378068659324107003086101259453222935263991809290097010748259547387191918802204660568909084353369956293
rrrrrr = 0x30c94d68cab2ea6d38d41c0bad18361a2a8b8b66091f297e407d56db052ef26a4054000000000000000000000000000000000000000000000000000000000000
bakha = 0x8469445c57bad20c6402fc591cdbf23cfccb0a9aba96fed87c199cf1e137102252ac000000000000000000000000000000000000000000000000000000000000
c = 0x37c012fc3bb382523797930b25a8b7fdc77e99d2ffe6d48f6af4af7ee591425ea088e8717b625650f49b95d128bfc0663a3132c32d897acfa4151d7f2e6f37af
ExNotChangeable = 6909194410234191894585961242353755857100310114223366009755312915035625198746755966774807330721995012155252253226178726566356100357341988158815947523380819259877182558769376535116678939053259587440186352109417599760247765144357054050744308456243381397151349385670430308696422950676962591509527725221139839592
n = 25433994087115135312901884073435176905221411951942397897477021660859779148705406450073400112301489098230018617938663663835807099386270369458418311374046724547029235935457132524907319006584670831659548927403777678545889472723389348115348451560307605036544220649875541852185142251808841874441655977755338409113

Z = pow(B, c, p)
B_ = 2^242

B = Matrix(ZZ, [
    [p, 0, 0],
    [Z, 1, 0],
    [(Z * rrrrrr - bakha) % p, 0, B_]
])

R = B.LLL()
x = R[0][0]
y = R[0][1]
S = rrrrrr + y
s = next_prime(S)
phi = s - 1
d = pow(e, -1, phi)
print(long_to_bytes(pow(ExNotChangeable, d, s)))
```
ðŸŽ¯ Flag:  MCSC{L477ice_solv3s_all????:jUs7_pl4y_w17h_DH}

